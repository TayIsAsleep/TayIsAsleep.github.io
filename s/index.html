<!DOCTYPE html>
<html id="l" lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <body>
        <script>
            var load_document_default_file_name = "default.html";
            var load_document_default_dest = document.getElementById('loader-here');

            async function load_document(fn, dest, ignore_same_page=false){
                let replacement_html = null;
                let load_to_top = false;

                if (fn != null && fn.slice(-1) == "#"){
                    fn = fn.slice(0, -1);
                    load_to_top = true;
                }
                if (fn == load_document_default_file_name || fn == "null"){fn = null;}
                if (dest == undefined || dest == null){dest = load_document_default_dest;}

                // Step 1: Check if it should load in the first place.
                if (dest.getAttribute("loaded") == `${fn}`){

                    if (!ignore_same_page){
                        console.log("Same page, ignoring request");
                        if (load_to_top){
                            scrollToTop()
                        }
                        return;
                    }
                    console.log("Was same page, but ignore_same_page is true")
                }

                // Step 2: Check cache.
                if (`${fn}` in loaded_pages_cache){
                    
                    console.log("Using cache!");
                    replacement_html = loaded_pages_cache[`${fn}`];
                }
                
                // Step 3: Make a new request
                if (replacement_html == null){

                    let response = await fetch((fn == null) ? load_document_default_file_name : fn)

                    if (response.status === 200){
                        let data = await response.text()
                        replacement_html = data;
                    }
                    
                }

                // Final step: Switch out data
                if (replacement_html != null){
                    // Replace content
                    dest.innerHTML = replacement_html;

                    // Fix classes and "loaded" property
                    if (dest.getAttribute("loaded") != null){
                        dest.classList.remove(`document-${dest.getAttribute("loaded")}`)
                    }
                    dest.classList.add(`document-${fn}`)
                    dest.setAttribute("loaded", `${fn}`);

                    // Save to cache
                    loaded_pages_cache[`${fn}`] = replacement_html;

                    // Update URL
                    history.pushState({},null,
                        (fn == null) ? window.location.pathname : `?d=${fn}`
                    );

                    if (load_to_top){
                        scrollToTop()
                    }

                    Array.from(dest.getElementsByClassName("run-after-load")).forEach(i => {
                        eval(i.innerHTML);
                    });

                    return 0;
                }

                return -1;
            };

            let app = new URLSearchParams(window.location.search).get('app');
            let all_apps = {
                "evidence_tracker":"me/phasmophobia/phasmo_tools/evidence_tracker.html",
                "item_randomizer":"me/phasmophobia/phasmo_tools/item_randomizer.html"
            }
            if (Object.keys(all_apps).includes(app)){
                app = all_apps[app];
            }
            else{
                app = "index.html";
            }
            
            let toload = `${window.location.origin}/${app}`;
            console.log(toload)

            console.log(load_document(app, document.querySelector("#l")))

            // window.location.replace();

        </script>
    </body>
</html>